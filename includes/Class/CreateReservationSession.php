<?php
namespace Stark {

    use Stark\Mappers\LoanContractMapper;
    use Stark\Mappers\LoanedEquipmentMapper;
    use Stark\Mappers\ReservationMapper;
    use Stark\Models\Reservation;
    use Stark\Models\User;
    use Stark\Utilities\ReservationManager;

    class CreateReservationSession
    {
        /**
         * @var \Stark\Models\User $_User The user that the session belongs to.
         */
        private $_user;

        /**
         * @var int $_roomId The unique Id for the room to be reserved.
         */
        private $_roomId;

        /**
         * @var string $_startTimeDate The start time for the room reservation.
         */
        private $_startTimeDate;

        /**
         * @var string $_endTimeDate The end time for the room reservation.
         */
        private $_endTimeDate;

        /**
         * @var string $_title The title of the reservation.
         */
        private $_title;

        /**
         * @var int $_repeats The number of repeating time blocks.
         */
        private $_repeats;

        /**
         * @var array $_equipmentIds The equipmentIds request for the reservation.
         */
        private $_equipmentIds;

        /**
         * @var ReservationManager $_reservationManager to check for reservation conflicts.
         */
        private $_reservationManager;

        /**
         * @var array $_errors The errors generated by the reservation sessions.
         */
        private $_errors;

        /**
         * Creates a new reservation session for the user with the supplied parameters.
         *
         * @param \Stark\Models\User $user The user that the session belongs to.
         * @param int $roomId The unique Id for the room to be reserved.
         * @param string $startTimeDate The start time for the room reservation.
         * @param string $endTimeDate The end time for the room reservation.
         * @param string $title The title of the reservation.
         * @param int $repeats The number of times to repeat the reservation.
         * @param array $equipmentIds (optional) The iDs of the equipment to be reserved.
         */
        public function __construct(User $user, $roomId, $startTimeDate, $endTimeDate, $title, $repeats, $equipmentIds = [])
        {
            $this->_user = $user;
            $this->_roomId = $roomId;
            $this->_startTimeDate = $startTimeDate;
            $this->_endTimeDate = $endTimeDate;
            $this->_title = $title;
            $this->_equipmentIds = $equipmentIds;
            $this->_repeats = $repeats;
            $this->_errors = [];
            $this->_reservationManager = new ReservationManager();
        }

        public function getErrors()
        {
            return $this->_errors;
        }

        public function setError($error)
        {
            $this->_errors[] = $error;
        }

        /**
         * @return boolean returns true if the reservation was successful with no time conflicts.
         *
         */
        public function reserve()
        {
            // TODO: Validate max 3 repeats as per requirements
            $repeatedDates = Utilities::getDateRepeats($this->_startTimeDate, $this->_endTimeDate, $this->_repeats);

            $isWaiting = !$this->validateRepeats($repeatedDates);

            // Create a repeated reservation based on the date repeats
            $reservationMapper = new ReservationMapper();

            foreach ($repeatedDates as $i => $date) {
                try {
                    // Create a pending reservation
                    $reservation = $reservationMapper->createReservation(
                        $this->_user->getUserId(),
                        $this->_roomId,
                        $date['start'],
                        $date['end'],
                        $this->_title,
                        $isWaiting);

                    // Add it to the unit of work
                    $reservationMapper->uowInsert($reservation);

                    // Commit the unit of work
                    $reservationMapper->commit();

                    // TODO : Check if equipmentIds are available for reservation and notify user
                    // Create a loan contract Id and associate request equipment
                    if (!empty($this->_equipmentIds)) {
                        $loanContractId = $this->associateLoanContract($reservation->getReservationID());
                        $this->associateLoanedEquipment($loanContractId, $this->_equipmentIds);
                    }

                } catch (\Exception $e) {
                    $this->setError($e->getMessage());
                }
            }

            return !$isWaiting;
        }

        /**
         * Validates that the requested dates cause no time conflicts with other reservations.
         *
         * @param array $repeatedDates The repeated dates for the reservation.
         * @return boolean The validation result.
         */
        private function validateRepeats(array $repeatedDates)
        {
            foreach ($repeatedDates as $repeatedDate) {

                $startTimeDate = $repeatedDate['start'];
                $endTimeDate = $repeatedDate['end'];

                $reservationConflicts = $this->_reservationManager
                    ->checkForConflictsPendingReservation($this->_roomId, $startTimeDate, $endTimeDate, $this->_equipmentIds);
                foreach ($reservationConflicts as $reservationConflict) {
                    array_push($this->_errors, $reservationConflict->getReasonForConflict());
                }
            }

            return empty($this->getErrors());
        }

        /**
         * Creates loan contract for reservation with the requested equipmentIds.
         *
         * @param int $reservationId The reservationId to associate with the loan contract.
         * @return int The id of the new loan contract, or -1 if the contract creation failed.
         */
        private function associateLoanContract($reservationId)
        {
            $loanContractMapper = new LoanContractMapper();

            try {
                $loanContract = $loanContractMapper->createLoanContract($reservationId);

                // Add it to the unit of work
                $loanContractMapper->uowInsert($loanContract);

            } catch (\Exception $e) {
                $this->setError($e->getMessage());
                return -1;
            }

            // Commit the unit of work
            $loanContractMapper->commit();

            if ($loanContract->getLoanContractiD() == null) {
                return -1;
            }

            return $loanContract->getLoanContractiD();
        }

        /**
         * Creates loan contract for reservation with the requested equipmentIds.
         *
         * @param int $loanContractId The loanContractId to associate with the loan contract.
         * @param array $equipmentIds The equipmentIds to associate with the loan contract.
         * @return void
         */
        private function associateLoanedEquipment($loanContractId, $equipmentIds)
        {
            $loanedEquipmentMapper = new LoanedEquipmentMapper();

            foreach ($equipmentIds as $equipmentId) {
                try {
                    $loanedEquipment = $loanedEquipmentMapper->createLoanedEquipment($loanContractId, $equipmentId);

                    // Add it to the unit of work
                    $loanedEquipmentMapper->uowInsert($loanedEquipment);

                } catch (\Exception $e) {
                    $this->setError($e->getMessage());
                }
            }

            // Commit the units of work
            $loanedEquipmentMapper->commit();

            // TODO : Return array of newly created entries?
        }
    }
}